<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>RUNRUN | 수동 코스 등록</title>
  <script
      src="//dapi.kakao.com/v2/maps/sdk.js?appkey=477a1cea9ecc7c2b3e69f3540a3986b4&libraries=services"></script>
  <style>
    :root {
      font-family: "Nunito Sans", "Noto Sans KR", sans-serif;
      --primary: #baff29;
      --bg: #f7f7f9;
      --text: #1a1c1e;
      --muted: #6c7278;
      --danger: #ff3d00;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
    }

    .page {
      max-width: 520px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 14px 18px;
      background: #fff;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    header h1 {
      font-size: 16px;
      font-weight: 800;
      margin: 0;
      flex: 1;
      text-align: center;
    }

    .icon-btn,
    .primary-btn,
    .chip-btn {
      border: none;
      border-radius: 999px;
      padding: 10px 18px;
      cursor: pointer;
      font-weight: 700;
      font-size: 13px;
      transition: opacity 0.15s;
    }

    .icon-btn {
      background: rgba(0, 0, 0, 0.04);
      padding: 8px 14px;
    }

    .primary-btn {
      background: var(--primary);
      color: #000;
    }

    .primary-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chip-btn {
      background: #fff;
      border: 1px solid rgba(0, 0, 0, 0.08);
      color: #1f2329;
    }

    .chip-btn.active {
      border-color: var(--primary);
      box-shadow: 0 2px 8px rgba(186, 255, 41, 0.45);
    }

    .controls {
      padding: 16px 18px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .info-card {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 16px;
      border-radius: 14px;
      background: #fff;
      border: 1px solid rgba(0, 0, 0, 0.05);
    }

    .info-card strong {
      display: block;
      font-size: 16px;
    }

    #map {
      flex: 1;
      min-height: 420px;
    }

    @media (max-width: 520px) {
      header h1 {
        font-size: 15px;
      }
    }
  </style>
</head>
<body>
<div class="page">
  <header>
    <button class="icon-btn" type="button" onclick="history.back()">뒤로</button>
    <h1>수동 등록</h1>
    <button class="primary-btn" type="button" id="saveBtn">코스 적용</button>
  </header>

  <section class="controls">
    <div class="chip-row">
      <button type="button" id="startDrawBtn" class="chip-btn">선 그리기 시작</button>
      <button type="button" id="stopDrawBtn" class="chip-btn">선 그리기 종료</button>
      <button type="button" id="pointModeBtn" class="chip-btn">점 찍기 모드 OFF</button>
      <button type="button" id="undoBtn" class="chip-btn">한 점 되돌리기</button>
      <button type="button" id="clearBtn" class="chip-btn">전체 지우기</button>
      <button type="button" id="clearPoiBtn" class="chip-btn">찍은 점 지우기</button>
    </div>
    <div class="chip-row">
      <button type="button" id="generateFromPointsBtn" class="chip-btn">경로 생성하기</button>
    </div>
    <div class="info-card">
      <div>
        <span style="font-size:12px;color:var(--muted);">현재 상태</span>
        <strong id="info">좌표 0개 / 거리 0 km</strong>
      </div>
      <div style="text-align:right;font-size:12px;color:var(--muted);">
        마라톤 42.195km 초과 시 자동 초기화 됩니다.
      </div>
    </div>
  </section>

  <div id="map"></div>
</div>

<script th:inline="none">
  const mapContainer = document.getElementById('map');
  const map = new kakao.maps.Map(mapContainer, {
    center: new kakao.maps.LatLng(37.5665, 126.9780),
    level: 5
  });
  const geocoder = new kakao.maps.services.Geocoder();

  const infoEl = document.getElementById('info');
  const saveBtn = document.getElementById('saveBtn');

  const MAX_DISTANCE_M = 42195;
  const STORAGE_KEY = "courseDraft";
  const API_BASE = "";

  let drawing = false;
  let pointMode = false;
  let points = [];
  let poiMarkers = [];
  let routeMarkers = [];
  let startMarker = null;
  let polyline = new kakao.maps.Polyline({
    map,
    path: [],
    strokeWeight: 5,
    strokeColor: '#ff3d00',
    strokeOpacity: 0.9
  });
  let startAddress = '';

  function haversine(a, b) {
    const R = 6371000;
    const dLat = (b.lat - a.lat) * Math.PI / 180;
    const dLng = (b.lng - a.lng) * Math.PI / 180;
    const lat1 = a.lat * Math.PI / 180;
    const lat2 = b.lat * Math.PI / 180;
    const c =
        Math.sin(dLat / 2) ** 2 +
        Math.cos(lat1) *
        Math.cos(lat2) *
        Math.sin(dLng / 2) ** 2;
    return 2 * R * Math.atan2(Math.sqrt(c), Math.sqrt(1 - c));
  }

  function calcDistance(coords) {
    if (!coords || coords.length < 2) {
      return 0;
    }
    let sum = 0;
    for (let i = 1; i < coords.length; i++) {
      sum += haversine(coords[i - 1], coords[i]);
    }
    return sum;
  }

  function ensureClosedLoop(list) {
    if (!list || list.length < 2) {
      return list;
    }
    const first = list[0];
    const last = list[list.length - 1];
    const dist = haversine(first, last);
    if (dist > 10) {
      list.push({...first});
    }
    return list;
  }

  function updateInfo() {
    const dist = calcDistance(points);
    infoEl.textContent = `좌표 ${points.length}개 / 거리 ${(dist / 1000).toFixed(2)} km`;
  }

  function refreshPolyline() {
    const path = points.map(p => new kakao.maps.LatLng(p.lat, p.lng));
    polyline.setPath(path);
    routeMarkers.forEach(m => m.setMap(null));
    routeMarkers = [];
    if (points.length) {
      const bounds = new kakao.maps.LatLngBounds();
      path.forEach(p => bounds.extend(p));
      map.setBounds(bounds);
    }
  }

  function clearPoiMarkers() {
    poiMarkers.forEach(p => p.setMap(null));
    poiMarkers = [];
  }

  async function reverseGeocode(lat, lng) {
    return new Promise((resolve) => {
      geocoder.coord2Address(lng, lat, (result, status) => {
        if (status === kakao.maps.services.Status.OK && result?.[0]) {
          const addr =
              result[0].road_address?.address_name ??
              result[0].address?.address_name ??
              "";
          resolve(addr);
        } else {
          resolve("");
        }
      });
    });
  }

  kakao.maps.event.addListener(map, 'click', async (mouseEvent) => {
    const latlng = mouseEvent.latLng;
    const lat = latlng.getLat();
    const lng = latlng.getLng();
    if (pointMode) {
      const marker = new kakao.maps.Marker({position: latlng, map});
      poiMarkers.push(marker);
      return;
    }
    if (!drawing) {
      return;
    }
    points.push({lat, lng});
    if (points.length === 1) {
      startMarker?.setMap(null);
      startMarker = new kakao.maps.Marker({position: latlng, map});
      startAddress = await reverseGeocode(lat, lng);
    }
    refreshPolyline();
    updateInfo();
  });

  document.getElementById('startDrawBtn').addEventListener('click', () => {
    drawing = true;
    alert('지도 위를 클릭해 경로를 그려주세요.');
  });

  document.getElementById('stopDrawBtn').addEventListener('click', () => {
    drawing = false;
    alert('선 그리기를 종료했습니다. 계속하려면 다시 시작을 눌러주세요.');
  });

  document.getElementById('pointModeBtn').addEventListener('click', (e) => {
    pointMode = !pointMode;
    e.currentTarget.textContent = pointMode ? '점 찍기 모드 ON' : '점 찍기 모드 OFF';
  });

  document.getElementById('undoBtn').addEventListener('click', () => {
    points.pop();
    if (!points.length && startMarker) {
      startMarker.setMap(null);
      startMarker = null;
      startAddress = '';
    }
    refreshPolyline();
    updateInfo();
  });

  document.getElementById('clearBtn').addEventListener('click', () => {
    points = [];
    startAddress = '';
    startMarker?.setMap(null);
    startMarker = null;
    refreshPolyline();
    updateInfo();
  });

  document.getElementById('clearPoiBtn').addEventListener('click', () => {
    clearPoiMarkers();
  });

  async function callApi(url, body) {
    const headers = {"Content-Type": "application/json"};
    const token = localStorage.getItem("accessToken");
    if (token) {
      headers["Authorization"] = `Bearer ${token}`;
    }
    const res = await fetch(API_BASE + url, {
      method: "POST",
      headers,
      body: JSON.stringify(body),
    });
    if (!res.ok) {
      const text = await res.text();
      throw new Error(
          `HTTP ${res.status}: ${text || "요청에 실패했습니다."}`
      );
    }
    return res.json();
  }

  document
  .getElementById("generateFromPointsBtn")
  .addEventListener("click", async () => {
    let source = [];
    if (poiMarkers.length >= 2) {
      source = poiMarkers.map((m) => {
        const pos = m.getPosition();
        return {lat: pos.getLat(), lng: pos.getLng()};
      });
    } else if (points.length >= 2) {
      source = [...points];
    } else {
      alert('최소 두 점 이상 지정해 주세요.');
      return;
    }

    const working = ensureClosedLoop(source.map(p => ({...p})));
    const draftDistance = calcDistance(working);
    if (draftDistance > MAX_DISTANCE_M) {
      alert('42.195km를 초과하는 코스는 만들 수 없습니다. 다시 그려주세요.');
      points = [];
      refreshPolyline();
      updateInfo();
      return;
    }

    try {
      const viaPoints = working.map(p => ({lat: p.lat, lng: p.lng}));
      const payload = {
        startLat: viaPoints[0].lat,
        startLng: viaPoints[0].lng,
        viaPoints
      };
      const data = await callApi("/api/routes/oneway", payload);
      if (!data?.lineString?.length) {
        throw new Error("경로 데이터를 받지 못했습니다.");
      }
      const converted = data.lineString.map(([lng, lat]) => ({lat, lng}));
      const distance = typeof data.totalDistance === "number"
          ? data.totalDistance
          : calcDistance(converted);
      if (distance > MAX_DISTANCE_M) {
        alert("42.195km를 초과하는 코스는 만들 수 없습니다. 다시 그려주세요.");
        points = [];
        refreshPolyline();
        updateInfo();
        return;
      }
      points = converted;
      if (points.length) {
        startAddress = await reverseGeocode(points[0].lat, points[0].lng);
        startMarker?.setMap(null);
        startMarker = new kakao.maps.Marker({
          position: new kakao.maps.LatLng(points[0].lat, points[0].lng),
          map
        });
      }
      refreshPolyline();
      updateInfo();
      alert('TMAP 경로를 생성했습니다. 필요하면 계속 수정 후 적용하세요.');
    } catch (err) {
      console.error(err);
      alert(err.message || "경로 생성 중 오류가 발생했습니다.");
    }
  });

  async function saveCourse() {
    if (points.length < 2) {
      alert('최소 두 점 이상으로 코스를 만들어 주세요.');
      return;
    }
    const distanceM = Math.round(calcDistance(points));
    if (distanceM > MAX_DISTANCE_M) {
      alert('42.195km 초과 코스는 저장할 수 없습니다.');
      return;
    }
    if (!startAddress && points.length) {
      startAddress = await reverseGeocode(points[0].lat, points[0].lng);
    }
    const payload = {
      path: {
        type: "LineString",
        coordinates: ensureClosedLoop([...points]).map(p => [p.lng, p.lat])
      },
      distanceM,
      startLat: points[0].lat,
      startLng: points[0].lng,
      address: startAddress || "",
      courseRegisterType: "MANUAL"
    };
    sessionStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
    // 저장된 returnPage가 있으면 그 페이지로, 없으면 기본값으로 courseCreate로
    const returnPage = sessionStorage.getItem("returnPage") || "/courseCreate";
    sessionStorage.removeItem("returnPage"); // 사용 후 삭제
    window.location.href = returnPage;
  }

  saveBtn.addEventListener('click', saveCourse);
</script>
</body>
</html>
