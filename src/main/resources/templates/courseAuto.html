<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>RUNRUN | 자동 코스 등록</title>
    <script src="//dapi.kakao.com/v2/maps/sdk.js?appkey=477a1cea9ecc7c2b3e69f3540a3986b4&libraries=services"></script>
    <style>
      :root {
        font-family: "Nunito Sans", "Noto Sans KR", sans-serif;
        --primary: #baff29;
        --bg: #f7f7f9;
        --text: #1a1c1e;
        --muted: #6c7278;
        --danger: #ff3d00;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: var(--bg);
        min-height: 100vh;
        color: var(--text);
      }

      .page {
        max-width: 520px;
        margin: 0 auto;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 14px 18px;
        background: #fff;
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        position: sticky;
        top: 0;
        z-index: 10;
      }

      header h1 {
        flex: 1;
        text-align: center;
        margin: 0;
        font-size: 16px;
        font-weight: 800;
      }

      .icon-btn,
      .chip-btn,
      .primary-btn {
        border: none;
        border-radius: 999px;
        font-weight: 700;
        font-size: 13px;
        cursor: pointer;
        transition: opacity 0.15s;
      }

      .icon-btn {
        background: rgba(0, 0, 0, 0.05);
        padding: 8px 16px;
      }

      .primary-btn {
        background: var(--primary);
        color: #000;
        padding: 10px 20px;
      }

      .primary-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .controls {
        padding: 18px;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .field-group {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .field-group label {
        font-weight: 700;
        font-size: 13px;
      }

      .input-row {
        display: flex;
        gap: 8px;
      }

      .text-input {
        flex: 1;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(0, 0, 0, 0.1);
        font-size: 14px;
      }

      .chip-row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .chip-btn {
        padding: 9px 16px;
        background: #fff;
        border: 1px solid rgba(0, 0, 0, 0.08);
        color: #1f2329;
      }

      .chip-btn:hover {
        opacity: 0.8;
      }

      .info-card {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        padding: 16px;
        background: #fff;
        border-radius: 16px;
        border: 1px solid rgba(0, 0, 0, 0.05);
      }

      .info-card strong {
        font-size: 16px;
        display: block;
      }

      .limit-note {
        font-size: 12px;
        color: var(--muted);
        text-align: right;
      }

      #map {
        flex: 1;
        min-height: 480px;
      }

      @media (max-width: 520px) {
        header h1 {
          font-size: 15px;
        }
      }
    </style>
  </head>
  <body>
    <div class="page">
      <header>
        <button class="icon-btn" type="button" onclick="history.back()">
          뒤로
        </button>
        <h1>자동 등록</h1>
        <button class="primary-btn" type="button" id="applyBtn" disabled>
          코스 적용
        </button>
      </header>

      <section class="controls">
        <div class="field-group">
          <label for="startInput">출발지 검색</label>
          <div class="input-row">
            <input
              id="startInput"
              class="text-input"
              placeholder="예) 광화문"
              autocomplete="off"
            />
          </div>
        </div>

        <div class="field-group">
          <label for="endInput">도착지 검색 (편도)</label>
          <div class="input-row">
            <input
              id="endInput"
              class="text-input"
              placeholder="예) 여의도"
              autocomplete="off"
            />
          </div>
        </div>

        <div class="field-group">
          <label for="kmInput">왕복 거리 (km)</label>
          <div class="input-row">
            <input
              id="kmInput"
              class="text-input"
              inputmode="decimal"
              placeholder="예: 5"
              value="5"
            />
          </div>
        </div>

        <div class="chip-row">
          <button type="button" id="onewayBtn" class="chip-btn">
            편도 생성
          </button>
          <button type="button" id="roundBtn" class="chip-btn">
            왕복 생성
          </button>
          <button type="button" id="clearRouteBtn" class="chip-btn">
            초기화
          </button>
        </div>

        <div class="info-card">
          <div>
            <span style="font-size: 12px; color: var(--muted)">현재 상태</span>
            <strong id="info">경로를 생성해 주세요.</strong>
          </div>
          <div class="limit-note">마라톤 42.195km 초과 시 코스 적용 불가</div>
        </div>
      </section>

      <div id="map"></div>
    </div>

    <script th:inline="none">
      const MAX_DISTANCE_M = 42195;
      const STORAGE_KEY = "courseDraft";
      const API_BASE = "";

      const startInput = document.getElementById("startInput");
      const endInput = document.getElementById("endInput");
      const kmInput = document.getElementById("kmInput");
      const infoEl = document.getElementById("info");
      const applyBtn = document.getElementById("applyBtn");

      const map = new kakao.maps.Map(document.getElementById("map"), {
        center: new kakao.maps.LatLng(37.5665, 126.978),
        level: 5,
      });
      const ps = new kakao.maps.services.Places();
      const infoWindow = new kakao.maps.InfoWindow({ removable: true });

      let polyline = null;
      let startMarker = null;
      let endMarker = null;
      let turnMarker = null;

      let currentMode = null;
      let currentLineString = null;
      let currentTotalDistanceM = null;
      let currentStart = null;
      let currentEnd = null;
      let currentTurn = null;

      function setApplyEnabled(enabled) {
        applyBtn.disabled = !enabled;
      }

      function resetState(message = "경로를 생성해 주세요.") {
        currentMode = null;
        currentLineString = null;
        currentTotalDistanceM = null;
        currentStart = null;
        currentEnd = null;
        currentTurn = null;

        if (polyline) {
          polyline.setMap(null);
          polyline = null;
        }
        clearMarker(startMarker);
        startMarker = null;
        clearMarker(endMarker);
        endMarker = null;
        clearMarker(turnMarker);
        turnMarker = null;
        infoWindow.close();

        infoEl.textContent = message;
        setApplyEnabled(false);
      }

      function clearMarker(marker) {
        if (marker) {
          marker.setMap(null);
        }
      }

      function searchKeyword(keyword) {
        return new Promise((resolve, reject) => {
          if (!keyword || !keyword.trim()) {
            reject(new Error("검색어를 입력해 주세요."));
            return;
          }
          ps.keywordSearch(keyword, (data, status) => {
            if (status !== kakao.maps.services.Status.OK || !data?.length) {
              reject(new Error(`검색 결과가 없습니다: ${keyword}`));
              return;
            }
            resolve(data[0]);
          });
        });
      }

      function addMarker(lat, lng, text) {
        const marker = new kakao.maps.Marker({
          position: new kakao.maps.LatLng(lat, lng),
          map,
        });
        kakao.maps.event.addListener(marker, "click", () => {
          infoWindow.setContent(
            `<div style="padding:8px 10px;font-size:12px;">${text}</div>`
          );
          infoWindow.open(map, marker);
        });
        return marker;
      }

      function setStartPlace(place) {
        const lat = Number(place.y);
        const lng = Number(place.x);
        const address =
          place.address_name || place.road_address_name || place.place_name;

        clearMarker(startMarker);
        startMarker = addMarker(lat, lng, `출발<br>${address}`);
        map.setCenter(new kakao.maps.LatLng(lat, lng));

        currentStart = { lat, lng, address };
        return currentStart;
      }

      function setEndPlace(place) {
        const lat = Number(place.y);
        const lng = Number(place.x);
        const address =
          place.address_name || place.road_address_name || place.place_name;

        clearMarker(endMarker);
        endMarker = addMarker(lat, lng, `도착<br>${address}`);
        currentEnd = { lat, lng, address };
        return currentEnd;
      }

      function setTurnMarker(lng, lat) {
        clearMarker(turnMarker);
        turnMarker = addMarker(lat, lng, `턴(반환점)`);
      }

      function drawRoute(coords) {
        if (polyline) {
          polyline.setMap(null);
        }
        const path = coords.map(
          ([lng, lat]) => new kakao.maps.LatLng(lat, lng)
        );
        polyline = new kakao.maps.Polyline({
          path,
          strokeWeight: 5,
          strokeColor: "#ff3d00",
          strokeOpacity: 0.9,
        });
        polyline.setMap(map);
        const bounds = new kakao.maps.LatLngBounds();
        path.forEach((p) => bounds.extend(p));
        map.setBounds(bounds);
      }

      function haversineMeters(lat1, lng1, lat2, lng2) {
        const R = 6371000;
        const toRad = (d) => (d * Math.PI) / 180;
        const dLat = toRad(lat2 - lat1);
        const dLng = toRad(lng2 - lng1);
        const a =
          Math.sin(dLat / 2) ** 2 +
          Math.cos(toRad(lat1)) *
            Math.cos(toRad(lat2)) *
            Math.sin(dLng / 2) ** 2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      function calcDistanceFromLineStringMeters(lineString) {
        if (!lineString || lineString.length < 2) {
          return 0;
        }
        let sum = 0;
        for (let i = 1; i < lineString.length; i++) {
          const [lng1, lat1] = lineString[i - 1];
          const [lng2, lat2] = lineString[i];
          sum += haversineMeters(lat1, lng1, lat2, lng2);
        }
        return Math.round(sum);
      }

      function interpolateCoordinate(prev, next, ratio) {
        const lng = prev[0] + (next[0] - prev[0]) * ratio;
        const lat = prev[1] + (next[1] - prev[1]) * ratio;
        return [lng, lat];
      }

      function clipLineStringToDistance(lineString, targetMeters) {
        if (!lineString || lineString.length < 2) {
          return { coords: [], distance: 0, hitTarget: false };
        }
        const coords = [lineString[0]];
        let accumulated = 0;
        for (let i = 1; i < lineString.length; i++) {
          const prev = lineString[i - 1];
          const curr = lineString[i];
          const segment = haversineMeters(prev[1], prev[0], curr[1], curr[0]);
          if (accumulated + segment < targetMeters - 1e-6) {
            coords.push(curr);
            accumulated += segment;
          } else {
            const remaining = Math.max(0, targetMeters - accumulated);
            if (segment > 0 && remaining > 0) {
              const ratio = remaining / segment;
              coords.push(
                interpolateCoordinate(prev, curr, Math.min(1, ratio))
              );
              accumulated += remaining;
            }
            break;
          }
        }
        if (accumulated < targetMeters - 1e-6) {
          return { coords, distance: accumulated, hitTarget: false };
        }
        return { coords, distance: targetMeters, hitTarget: true };
      }

      function buildRoundTripWithTarget(lineString, desiredTotalMeters) {
        if (!lineString || lineString.length < 2 || desiredTotalMeters <= 0) {
          return null;
        }
        const halfTarget = desiredTotalMeters / 2;
        const clipped = clipLineStringToDistance(lineString, halfTarget);
        if (!clipped.coords.length) {
          return null;
        }
        const outward = clipped.coords;
        const returnSegment = outward.slice(0, -1).reverse();
        const fullCoords = outward.concat(returnSegment);
        const turnCoord = outward[outward.length - 1];
        return {
          coords: fullCoords,
          roundTripDistance: clipped.distance * 2,
          outboundDistance: clipped.distance,
          hitTarget: clipped.hitTarget,
          turnPoint: turnCoord,
        };
      }

      async function callApi(url, body, { auth = false } = {}) {
        const headers = { "Content-Type": "application/json" };
        if (auth) {
          const token = localStorage.getItem("accessToken");
          if (!token) {
            throw new Error("accessToken을 먼저 저장해 주세요.");
          }
          headers["Authorization"] = `Bearer ${token}`;
        } else {
          const token = localStorage.getItem("accessToken");
          if (token) {
            headers["Authorization"] = `Bearer ${token}`;
          }
        }
        const res = await fetch(API_BASE + url, {
          method: "POST",
          headers,
          body: JSON.stringify(body),
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(`HTTP ${res.status} - ${text}`);
        }
        return res.json();
      }

      function enforceDistanceLimit(distance) {
        if (distance > MAX_DISTANCE_M) {
          alert(
            "42.195km를 초과하는 코스는 만들 수 없습니다. 다른 경로를 선택해 주세요."
          );
          resetState();
          return false;
        }
        return true;
      }

      function handleRouteResult(lineString, distance, modeText) {
        currentLineString = lineString;
        currentTotalDistanceM = distance;
        drawRoute(lineString);

        const distanceKm = (distance / 1000).toFixed(2);
        const startText = currentStart?.address ?? "-";
        const endText =
          currentMode === "ONEWAY"
            ? currentEnd?.address ?? "-"
            : currentTurn
            ? `반환점까지 ${(currentTurn.dist / 1000).toFixed(2)}km`
            : "-";

        infoEl.innerText =
          `${modeText}\n거리: ${distanceKm} km\n출발: ${startText}\n` +
          (currentMode === "ONEWAY" ? `도착: ${endText}` : endText);
        setApplyEnabled(true);
      }

      async function handleOneway() {
        try {
          const startPlace = await searchKeyword(startInput.value);
          const start = setStartPlace(startPlace);
          const endPlace = await searchKeyword(endInput.value);
          const end = setEndPlace(endPlace);

          const data = await callApi("/api/courses/oneway", {
            startLat: start.lat,
            startLng: start.lng,
            endLat: end.lat,
            endLng: end.lng,
          });

          if (!data?.lineString?.length) {
            alert("경로 데이터를 받지 못했습니다.");
            return;
          }

          const distance =
            typeof data.totalDistance === "number"
              ? data.totalDistance
              : calcDistanceFromLineStringMeters(data.lineString);

          if (!enforceDistanceLimit(distance)) {
            return;
          }

          currentMode = "ONEWAY";
          clearMarker(turnMarker);
          currentTurn = null;
          handleRouteResult(data.lineString, distance, "편도 코스");
        } catch (err) {
          console.error(err);
          alert(err.message);
        }
      }

      async function handleRoundTrip() {
        const km = Number(kmInput.value);
        if (!Number.isFinite(km) || km <= 0) {
          alert("왕복 거리를 올바르게 입력해 주세요.");
          return;
        }
        try {
          const startPlace = await searchKeyword(startInput.value);
          const start = setStartPlace(startPlace);

          const data = await callApi("/api/courses/round", {
            startLat: start.lat,
            startLng: start.lng,
            distanceKm: km,
          });

          if (!data?.lineString?.length) {
            alert("경로 데이터를 받지 못했습니다.");
            return;
          }

          const builder = buildRoundTripWithTarget(data.lineString, km * 1000);
          if (!builder) {
            alert("요청한 거리로 왕복 경로를 만들 수 없습니다.");
            return;
          }

          if (!enforceDistanceLimit(builder.roundTripDistance)) {
            return;
          }

          currentMode = "ROUND";
          currentTurn = builder.turnPoint
            ? {
                lat: builder.turnPoint[1],
                lng: builder.turnPoint[0],
                dist: builder.outboundDistance,
              }
            : null;

          if (currentTurn) {
            setTurnMarker(currentTurn.lng, currentTurn.lat);
          } else {
            clearMarker(turnMarker);
          }

          handleRouteResult(
            builder.coords,
            builder.roundTripDistance,
            currentTurn
              ? `왕복 코스 (반환점까지 ${(currentTurn.dist / 1000).toFixed(
                  2
                )} km)`
              : "왕복 코스"
          );
        } catch (err) {
          console.error(err);
          alert(err.message);
        }
      }

      function buildDraftPayload() {
        if (
          !currentLineString ||
          currentLineString.length < 2 ||
          !currentStart
        ) {
          alert("먼저 경로를 생성해 주세요.");
          return null;
        }
        const distance =
          typeof currentTotalDistanceM === "number"
            ? currentTotalDistanceM
            : calcDistanceFromLineStringMeters(currentLineString);
        if (!enforceDistanceLimit(distance)) {
          return null;
        }
        return {
          path: {
            type: "LineString",
            coordinates: currentLineString,
          },
          distanceM: Math.round(distance),
          startLat: currentStart.lat,
          startLng: currentStart.lng,
          address: currentStart.address || "",
          courseRegisterType: "AUTO",
        };
      }

      function applyCourse() {
        const payload = buildDraftPayload();
        if (!payload) {
          return;
        }
        sessionStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
        // 저장된 returnPage가 있으면 그 페이지로, 없으면 기본값으로 courseCreate로
        const returnPage =
          sessionStorage.getItem("returnPage") || "/courseCreate";
        sessionStorage.removeItem("returnPage"); // 사용 후 삭제
        window.location.href = returnPage;
      }

      document
        .getElementById("onewayBtn")
        .addEventListener("click", handleOneway);
      document
        .getElementById("roundBtn")
        .addEventListener("click", handleRoundTrip);
      document
        .getElementById("clearRouteBtn")
        .addEventListener("click", () => resetState());
      applyBtn.addEventListener("click", applyCourse);

      resetState();
    </script>
  </body>
</html>
